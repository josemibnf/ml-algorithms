import sys
 
def read(file_name):
    ret = []
    with open(file_name, 'r') as f:
 
        for line in f:
            treated_line = line.rstrip('\n').split('\t')
            ret.append(treated_line)
 
    return ret
 
 
def unique_counts(part):
    res = {}

    for elem in part:
        if elem[-1] not in res:
            res[elem[-1]] = 1
        else:
            res[elem[-1]] += 1
 
    return res


def gini_impurity(part):
    total = len(part)
    results = unique_counts(part)
    imp = 0

    for v in results.values():
        imp += (v / float(total))**2
    return 1 - imp


def entropy(rows):
    from math import log
    total = len(rows)
    results = unique_counts(rows)
    ent = 0.0
 
    for v in results.values():
        p = v / float(total)
        ent -= p * log(p, 2)
 
    return ent
 
 
def divide_set(part, column, value):
    def split_fun(prot): return prot[column] == value
    if isinstance(value, int) or isinstance(value, float):
        def split_fun(prot): return prot[column] <= value

    set1, set2 = [], []
    for elem in part:
        if split_fun(elem):
            set1.append(elem)
        else:
            set2.append(elem)
    return (set1, set2)

 
def decisionnode():
 
    def __init__(self, col=-1, value=None, results=None, tb=None, fb=None):
        self.col = col 
        self.value = value
        self.results = results
        self.tb = results[0]
        self.fb = results[1]
 
    return __init__()
 
def buildtree(part, scoref=gini_impurity, beta=0):
    if len(part) == 0:
        return decisionnode()
    current_score = scoref(part)
    #Set up some variables to track the best criteria
    best_gain = 0
    best_criteria = None
    best_sets = None
    set1f=0
    set2f=0
    for column, value in part:
        set1, set2 = divide_set(part, column, value)

    if current_score > beta:
        return buildtree(set1, scoref, beta) and  buildtree(set2, scoref, beta)
    else: #es homogeneo
        return decisionnode(results=unique_counts(part))
 
 
def printtree(tree, indent=''):
    # Is this a leaf node?
    if tree.results is not None:
        print(indent+str(tree.results))
    else:
        # Print the criteria
        print(indent + str(tree.col)+':'+str(tree.value)+'? ')
        # Print the branches
        print(indent+'T->')
        printtree(tree.tb, indent+'  ')
        print(indent+'F->')
        printtree(tree.fb, indent+'  ')
       
 
def classify(obj, tree):
    pass
 
 
def test_performance(testset, trainingset):
    pass
 
 
def prune(tree, threshold):
    pass

def transpostedMatrix(data):
    return [list(elem) for elem in zip(*data)]
 
if __name__ == "__main__":
    dat_file = read(sys.argv[1])
    counts = unique_counts(dat_file)
    gini = gini_impurity(dat_file)
    ent = entropy(dat_file)
    tree = buildtree(part=dat_file)
 
    print("Training Set:\n", dat_file)
    print("Goal Attributes:", counts)
    print("Gini Index:", gini)
    print("Entropy:", ent)
 
    print("Build Tree: ", tree)
    #print("Print Tree: ", printtree(tree))
    #print('Divide set: (Location, New Zealand)\n', divide_set(dat_file, 1, 'New Zealand'))
